#/bin/bash

# How to use:
# 
# $0 mode pathToTestFile[s] [delayInMilliseconds]
#
# mode should be either "rshell", "bash",
# or the path to an executable
#


red() {
  echo -en "\033[1;31m"
  echo -n "$@"
  echo -en "\033[0m"
}


usage() {
  cat >&2 <<EOF
Usage: $(basename $0) mode pathToTestFile[s] [delayInMilliseconds]
mode should be one of "rshell", "bash", or the path
to an executable
EOF
}


# 2 or 3 arguments
if [[ $# < 2 || $# > 3 ]]
then
  red "Error: "
  echo "improper number of parameters" >&2
  usage
  exit 1
fi

MODE=$1
TEST_CASE_FILES=$2
U_DELAY=${3:-100000}
CUR_PID=$$



# test if $1 is a valid mode (rshell, bash, or executable)
if [[ "$MODE" != "rshell" && "$MODE" != "bash" && ! -x "$MODE" ]]
then
  red "Error: "
  echo "improper mode" >&2
  usage
  exit 1
fi

# for rshell mode, make sure there's something to execute
if [[ "$MODE" == "rshell" && ! -x bin/rshell ]]
then
  red "Error: "
  echo "bin/rshell cannot be executed" >&2
  usage
  exit 1
fi

# $2* must be a file or expand to a list of files
for file in $TEST_CASE_FILES*
do
  if [[ ! -f $file ]]
  then
    red "Error: "
    echo "$file not a file" >&2
    usage
    exit 1
  fi
done

# $3 must be exclusively numbers
if [[ ! "$U_DELAY" =~ ^[0-9]+$ ]]
then
  red "Error: "
  echo "\"$U_DELAY\" is not a valid number of microseconds" >&2
  usage
  exit 1
fi




# TODO: implement pausing
yieldLines() {
  while read -u 3 line
  do

    usleep $U_DELAY


    if [[ ${line} == "" ]]
    then
      # send SIGTSTP to subprocess responsible for executing commands
      kill -s SIGTSTP \
          $(ps --sort=start_time --ppid $CUR_PID \
          | awk 'NR==3 { print $1 }')
      # print "^Z"
      echo "^Z" >/proc/$CUR_PID/fd/1
      continue
    fi
    if [[ ${line} == "" ]]
    then
      # send SIGINT to subprocess responsible for executing commands
      kill -s SIGINT \
          $(ps --sort=start_time --ppid $CUR_PID \
          | awk 'NR==3 { print $1 }')
      # print "^C"
      echo "^C" >/proc/$CUR_PID/fd/1
      continue
    fi


    if [[ "$MODE" != "bash" ]] # anything other than bash (rshell or possibly homebrew stuff)
    then
      echo ${line} >/proc/$CUR_PID/fd/1 # to the screen
    fi

    echo ${line}
  done 3<$1
}


for file in $TEST_CASE_FILES*
do
  stars="********************************************************************************"
  numStars=`bc <<< "${#file} + 4"`

  echo "${stars:0:$numStars}"
  echo "* $file *"
  echo "${stars:0:$numStars}"

  echo ================================================================================
  if [[ "$MODE" == "rshell" ]]
  then
    yieldLines $file | bin/rshell
  elif [[ "$MODE" == "bash" ]]
  then
    yieldLines $file | bash -i
  else # executable program (non-standard rshell path?)
    yieldLines $file | $MODE
  fi
  echo ================================================================================
done



